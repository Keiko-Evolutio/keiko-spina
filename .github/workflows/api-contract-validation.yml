name: API Contract Validation

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'api-contracts/**'
      - 'scripts/api_contract_validator.py'
      - '.github/workflows/api-contract-validation.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'api-contracts/**'
      - 'scripts/api_contract_validator.py'
      - '.github/workflows/api-contract-validation.yml'

jobs:
  validate-api-contracts:
    name: Validate API Contracts
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Protocol Buffers Compiler
      run: |
        sudo apt-get update
        sudo apt-get install -y protobuf-compiler
        protoc --version
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml jsonschema openapi-spec-validator requests
        
    - name: Validate OpenAPI Specifications
      run: |
        echo "üîç Validating OpenAPI specifications..."
        python scripts/api_contract_validator.py
        
    - name: Upload validation report
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: api-contract-validation-report
        path: api_contract_validation_report.md
        
    - name: Comment PR with validation results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          try {
            const report = fs.readFileSync('api_contract_validation_report.md', 'utf8');
            
            const comment = `## üîç API Contract Validation Results
            
            ${report}
            
            ---
            *This comment was automatically generated by the API Contract Validation workflow.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          } catch (error) {
            console.log('Could not read validation report:', error.message);
          }

  contract-compatibility-check:
    name: Contract Compatibility Check
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout PR branch
      uses: actions/checkout@v4
      with:
        ref: ${{ github.head_ref }}
        
    - name: Checkout main branch
      uses: actions/checkout@v4
      with:
        ref: main
        path: main-branch
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml jsonschema openapi-spec-validator requests
        
    - name: Check API compatibility
      run: |
        echo "üîÑ Checking API contract compatibility..."
        
        # Compare OpenAPI specs for breaking changes
        python -c "
        import yaml
        import sys
        from pathlib import Path
        
        def load_openapi_spec(file_path):
            try:
                with open(file_path, 'r') as f:
                    return yaml.safe_load(f)
            except:
                return None
        
        def check_breaking_changes(old_spec, new_spec, file_name):
            breaking_changes = []
            
            if not old_spec or not new_spec:
                return breaking_changes
                
            # Check version changes
            old_version = old_spec.get('info', {}).get('version', '0.0.0')
            new_version = new_spec.get('info', {}).get('version', '0.0.0')
            
            if old_version != new_version:
                print(f'üìã {file_name}: Version changed from {old_version} to {new_version}')
            
            # Check for removed endpoints
            old_paths = set(old_spec.get('paths', {}).keys())
            new_paths = set(new_spec.get('paths', {}).keys())
            removed_paths = old_paths - new_paths
            
            if removed_paths:
                breaking_changes.extend([f'Removed endpoint: {path}' for path in removed_paths])
            
            # Check for removed required parameters
            for path in old_paths & new_paths:
                old_path_spec = old_spec['paths'][path]
                new_path_spec = new_spec['paths'][path]
                
                for method in old_path_spec.keys() & new_path_spec.keys():
                    old_params = old_path_spec.get(method, {}).get('parameters', [])
                    new_params = new_path_spec.get(method, {}).get('parameters', [])
                    
                    old_required = {p['name'] for p in old_params if p.get('required', False)}
                    new_required = {p['name'] for p in new_params if p.get('required', False)}
                    
                    removed_required = old_required - new_required
                    if removed_required:
                        breaking_changes.extend([f'{method.upper()} {path}: Removed required parameter {param}' for param in removed_required])
            
            return breaking_changes
        
        # Check all OpenAPI files
        openapi_files = list(Path('api-contracts/openapi').glob('**/*.yaml'))
        all_breaking_changes = []
        
        for openapi_file in openapi_files:
            main_file = Path('main-branch') / openapi_file
            
            old_spec = load_openapi_spec(main_file)
            new_spec = load_openapi_spec(openapi_file)
            
            breaking_changes = check_breaking_changes(old_spec, new_spec, openapi_file.name)
            if breaking_changes:
                all_breaking_changes.extend([f'{openapi_file.name}: {change}' for change in breaking_changes])
        
        if all_breaking_changes:
            print('‚ùå BREAKING CHANGES DETECTED:')
            for change in all_breaking_changes:
                print(f'  - {change}')
            sys.exit(1)
        else:
            print('‚úÖ No breaking changes detected')
        "
        
    - name: Comment PR with compatibility results
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const { execSync } = require('child_process');
          
          try {
            execSync('python -c "print(\\"‚úÖ API contracts are backward compatible\\")"');
            
            const comment = `## üîÑ API Contract Compatibility Check
            
            ‚úÖ **No breaking changes detected**
            
            All API contracts maintain backward compatibility with the main branch.
            
            ---
            *This comment was automatically generated by the Contract Compatibility Check workflow.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          } catch (error) {
            const comment = `## üîÑ API Contract Compatibility Check
            
            ‚ùå **Breaking changes detected**
            
            Please review the compatibility check logs for details on breaking changes.
            Consider incrementing the major version number if breaking changes are intentional.
            
            ---
            *This comment was automatically generated by the Contract Compatibility Check workflow.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }

  schema-drift-detection:
    name: Schema Drift Detection
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml jsonschema
        
    - name: Detect schema drift
      run: |
        echo "üîç Detecting schema drift..."
        
        python -c "
        import yaml
        import json
        from pathlib import Path
        from datetime import datetime
        
        def extract_schemas_from_openapi(file_path):
            try:
                with open(file_path, 'r') as f:
                    spec = yaml.safe_load(f)
                return spec.get('components', {}).get('schemas', {})
            except:
                return {}
        
        def extract_schemas_from_asyncapi(file_path):
            try:
                with open(file_path, 'r') as f:
                    spec = yaml.safe_load(f)
                return spec.get('components', {}).get('schemas', {})
            except:
                return {}
        
        # Sammle alle Schemas
        all_schemas = {}
        
        # OpenAPI Schemas
        for openapi_file in Path('api-contracts/openapi').glob('**/*.yaml'):
            schemas = extract_schemas_from_openapi(openapi_file)
            for schema_name, schema_def in schemas.items():
                if schema_name in all_schemas:
                    print(f'‚ö†Ô∏è Schema drift detected: {schema_name} defined in multiple files')
                all_schemas[schema_name] = {
                    'definition': schema_def,
                    'source': str(openapi_file),
                    'type': 'openapi'
                }
        
        # AsyncAPI Schemas
        for asyncapi_file in Path('api-contracts/asyncapi').glob('**/*.yaml'):
            schemas = extract_schemas_from_asyncapi(asyncapi_file)
            for schema_name, schema_def in schemas.items():
                if schema_name in all_schemas:
                    print(f'‚ö†Ô∏è Schema drift detected: {schema_name} defined in multiple files')
                    print(f'  - OpenAPI: {all_schemas[schema_name][\"source\"]}')
                    print(f'  - AsyncAPI: {asyncapi_file}')
                
        # Speichere Schema-Inventar
        schema_inventory = {
            'generated_at': datetime.now().isoformat(),
            'total_schemas': len(all_schemas),
            'schemas': {name: {'source': info['source'], 'type': info['type']} for name, info in all_schemas.items()}
        }
        
        with open('schema_inventory.json', 'w') as f:
            json.dump(schema_inventory, f, indent=2)
            
        print(f'üìä Schema inventory generated: {len(all_schemas)} schemas found')
        "
        
    - name: Upload schema inventory
      uses: actions/upload-artifact@v3
      with:
        name: schema-inventory
        path: schema_inventory.json
